TreeMap:
Pentru a crea un arbore ii alocam acestuia memorie si ii setam fiecare camp.
La functia isEmpty testam daca arborele este NULL sau daca este gol.
Pentru search comparam elementul cu nodul in care ne aflam si in functie de acesta ne mutam in stanga sau in dreapta pana cand gasim valoarea cautata.
Pentru minimum si maximum plecam de la root si parcurgem arborele in stanga sau drepta pana la NULL, gasind extremitatea arborelui.
Pentru succesor avem doua cazuri.Daca acesta are element in dreapta gasim minimum din arborele drept. In cazul in care nu avem trebuie sa parcurgem arborele venind din dreapta atata timp cat urcam in linie drepta(cat nodul este egal cu copilul drept al parintelui). In mod asemanator procedam si la predecesor.
La rotatii testam mai intai daca nodul din care se va produce shimbarea are parinte sau nu. Schimbam locul copiilor pentru a face rotatie(asa cum este prezentat si in desen) si actualizam parintele daca este cazul.La final trebuie sa actualizam si inaltimile.
Pentru balance returnam diferenta dintre inaltimea din arborele stang si cel drept
La functia de fixare testam pentru fiecare nod daca este balansat sau nu. Daca nu este aflam care arbore(stang sau drept) este mai inalt. Daca cel din stanga este mai mare atunci fixam arborele printr-o rotatie la dreapta, in caz contrar procedam invers.
Pentru insert avem cazul in care arborele este gol si atunci adaugam direct nodul. Daca are deja elemente parcurgem arborele pana la locul in care trebuie inserat elementul comparand nodul in care ne aflam cu valoarea ce trebuie inserata. Daca elementul deja exista in arbore atunci il adaugam doar in lista, folosindu-ne de pointerul catre ultimul element din lista de dubluri. Daca acesta nu exista, il punem si in arbore si in lista. Atunci cand il adaugam in lista trebuie sa ne folosim de predecesorul si succesorul nodului nou adaugat, setand next si prev pentru acesta. Daca prev are dubluri, prev va fi constituit din ultimul element al acestora(pred->end).
Pentru functia de delete cautam nodul ce trebuie sters. Daca are dubluri stergem ultimul element dintre acestea, folosindu-ne de pointerul nod->end. In cazul in care nu are, din lista doar reactualizam prev si next ai nodului. In arbore vom trata 3 cazuri, daca nodul este de tip frunza, daca are un copil in stanga sau dreapta sau daca are doi copii. Daca este frunza doar il eliminam, daca are un copil il mutam la parintele nodului, iar daca are doi copii ne folosim de succesor, schimband locurile acestora. Dupa ce facem acest lucru eliminam nodul mutat ce se va afla in unul din cele 2 cazuri prezentate anterior.
Pentru a distruge arborele il parcurgem cu ajtorul listei, eliminand fiecare element. Dupa ce l-am golit vom elibera si memoria alocata acestuia.
Cipher:
Citim codul din fisier, retinem fiecare cuvant intr-o matrice, dupa care calculam indexul.In cazul in care cuvantul depaseste 5 litere, il vom trunchia. Dupa ce avem aceste doua elemente ne folosim de functia insert pentru a crea arborele.
Pentru inorder si range parcurgem lista de la minimum de arbore si salvam info-ul fiecarui element in vectorul range-ului, insa la cea dea doua functie mai avem si conditia ca elementul sa se afle intre cei doi parametrii(p si q).
